// Многопоточность_1.cpp 

/*thread*/

/*В любом процессе создаётся уникальный поток выполнения, который называется основным потоком. 
Он может с помощью операционной системы запускать или порождать другие потоки, 
которые делят то же адресное пространство родительского процесса 
(сегмент кода, сегмент данных, а также другие ресурсы операционной системы, такие как открытые файлы и сигналы). 
С другой стороны, у каждого потока есть свой идентификатор потока, стек, набор регистров и счётчик команд. 
По сути, поток представляет собой легковесный процесс, 
в котором переключение между потоками происходит быстрее, а взаимодействие между процессами — легче.
*/
/* Запуск потока|std::thread t(callable_object, arg1, arg2, ..) 
Создаёт новый поток выполнения, ассоциируемый с t, 
который вызывает callable_object(arg1, arg2). 
Вызываемый объект (т.е. указатель функции, лямбда-выражение, экземпляр класса с вызовом функции operator) 
немедленно выполняется новым потоком с (выборочно) передаваемыми аргументами. Они копируются по умолчанию. 
Если хотите передать по ссылке, придётся использовать метод warp к аргументу с помощью std::ref(arg). 
Не забывайте: если хотите передать unique_ptr, то должны переместить его (std::move(my_pointer)), так как его нельзя копировать.
*/
/*Жизненный цикл потока| t.join() и t.detach()
Если основной поток завершает выполнение, все второстепенные сразу останавливаются без возможности восстановления. 
Чтобы этого не допустить, у родительского потока имеются два варианта для каждого порождённого:
 → Блокирует и ждёт завершения порождённого потока, вызывая на нём метод join.
 → Прямо объявляет, что порождённый поток может продолжить выполнение даже после завершения родительского, используя метод detach.
*/

#include <iostream>
#include <thread>  //для работы с потоками
#include <chrono> //для работы с временем

using namespace std;

//Сделаем функцию котора будет выполняться длительный период времени
void doFoo() {
    for (size_t i = 0;i < 10;i++) {
        cout << "ID = " << this_thread::get_id() << "\tdoFoo" << endl;
        this_thread::sleep_for(chrono::seconds(2));
    }
}

void doFoo2() {
    for (size_t i = 0;i < 5;i++) {
        cout << "ID = " << this_thread::get_id() << "\tdoFoo" << endl;
        this_thread::sleep_for(chrono::milliseconds(500));
    }
}


int main()
{
    /*cout << "START" << endl;
    this_thread::sleep_for(chrono::milliseconds(5000)); - задержка на 5 с
    cout << this_thread::get_id() << endl; - получить идентификатор, каждый раз при компиляции получаем новый
    cout << "END" << endl;
    */

    doFoo(); //сначала срабатывает функция 
    //Рассмотрим простейший цикл, состояшийся из 5 итерации
    for (size_t i = 0;i < 5;i++) {
        cout << "ID = " << this_thread::get_id()<<"\tMain"<<endl;
        this_thread::sleep_for(chrono::seconds(2));
    } 
    //При каждой итерации у нас задержка на 2 с
    //можем заметить что в результате один и тот же идентификатор 
    //Это означает что они компайлируются в один и тот же поток

    cout << "________________________________________________________________________________________________________\n";
    cout << "detach & join" << endl << endl;

    //Создаем новый поток
    thread th(doFoo2); //Передает указатель на данную функцию
    //Нельзя его просто так вызывать для этого у нас есть особые функции detach& join
    //Можно создавать несколько потоков 
    //Скомпайлируется ли эта программа или нет зависит от разрядности процессора
   // th.detach();
    for (size_t i = 0;i < 5;i++) {
        cout << "ID = " << this_thread::get_id() << "\tMain" << endl;
        this_thread::sleep_for(chrono::seconds(1));
    }
    //th.join();

}
